{
    "name": "heyo",
    "parallelism": 1,
    "query": "create table mqtt_sink (\n) with (\n    connector = 'mqtt',\n    url = 'mqtt://mosquitto:1883',\n    type = 'sink',\n    format = 'json',\n    topic = 'events'\n);\nINSERT INTO mqtt_sink \nwith pre as (\n    select \n        json_get(value,'data','time') as ts,\n        buy_sum(value) as buy_sum,\n        sell_sum(value) as sell_sum\n    from {}}\n),\npost as (\nselect \n    tumble(interval '1 seconds') over (order by ts asc) as time,\n    avg(buy_sum) as avg_buy_vol,\n    avg(sell_sum) as avg_sell_vol,\n    avg(buy_sum/sell_sum) as avg_ob_pressure\nfrom pre\ngroup by time)\n\nselect \n    get_field(time,'start') as start_time,\n    avg_buy_vol,\n    avg_sell_vol,\n    avg_ob_pressure\nfrom\n    post\n",
    "udfs": [
        {
            "definition": "/*\n[dependencies]\nserde = { version = \"1.0\", features = [\"derive\"] }\nserde_json = \"1.0\"\n*/\n\nuse arroyo_udf_plugin::udf;\nuse serde_json::Value;\n\n// interface WsLevel {\n//   px: string; // price\n//   sz: string; // size\n//   n: number; // number of orders\n// }\n\nuse std::any::type_name;\n\nfn print_type_of<T>(_: &T) {\n    println!(\"Type: {}\", type_name::<T>());\n}\n\n#[udf]\nfn sell_sum(x: &str) -> f64 {\n    println!(\"Input data: {}\", x);\n    \n    // Attempt to parse the input string into a JSON value\n    let trade: Value = match serde_json::from_str(x) {\n        Ok(val) => val,\n        Err(_) => {\n            return -1.0;\n        }\n    };\n\n    // Extract the timestamp\n    let timestamp = trade.pointer(\"/data/time\")\n        .and_then(|v| v.as_i64())\n        .unwrap_or(0);\n\n    // Extract \"levels\" from \"data\" safely\n    let levels = trade.pointer(\"/data/levels\");\n\n    let (buys, sells) = if let Some(levels) = levels {\n        if let Some(levels_array) = levels.as_array() {\n            // Extract buys (index 0) and convert to integer values in arrays, appending timestamp\n            let buys = levels_array.get(0)\n                .and_then(|v| v.as_array())\n                .map(|array| array.iter().map(|item| {\n                    match item {\n                        Value::Object(map) => {\n                            let n = map.get(\"n\")\n                                .and_then(|v| v.as_i64()) // Parse `n` as i64\n                                .map(|v| v as f64)\n                                .unwrap_or(0.0);\n                            let px = map.get(\"px\")\n                                .and_then(|v| v.as_str())\n                                .and_then(|s| s.parse::<f64>().ok())\n                                .unwrap_or(0.0);\n                            let sz = map.get(\"sz\")\n                                .and_then(|v| v.as_str())\n                                .and_then(|s| s.parse::<f64>().ok())\n                                .unwrap_or(0.0);\n                            vec![n, px, sz]\n                        }\n                        _ => vec![0.0, 0.0, 0.0]\n                    }\n                }).collect::<Vec<Vec<f64>>>())\n                .unwrap_or_else(|| vec![]);\n\n            // Extract sells (index 1) and convert to integer values in arrays, appending timestamp\n            let sells = levels_array.get(1)\n                .and_then(|v| v.as_array())\n                .map(|array| array.iter().map(|item| {\n                    match item {\n                        Value::Object(map) => {\n                            let n = map.get(\"n\")\n                                .and_then(|v| v.as_i64()) // Parse `n` as i64\n                                .map(|v| v as f64)\n                                .unwrap_or(0.0);\n                            let px = map.get(\"px\")\n                                .and_then(|v| v.as_str())\n                                .and_then(|s| s.parse::<f64>().ok())\n                                .unwrap_or(0.0);\n                            let sz = map.get(\"sz\")\n                                .and_then(|v| v.as_str())\n                                .and_then(|s| s.parse::<f64>().ok())\n                                .unwrap_or(0.0);\n                            vec![n, px, sz]\n                        }\n                        _ => vec![0.0, 0.0, 0.0]\n                    }\n                }).collect::<Vec<Vec<f64>>>())\n                .unwrap_or_else(|| vec![]);\n\n            (buys, sells)\n        } else {\n            (vec![], vec![])\n        }\n    } else {\n        (vec![], vec![])\n    };\n\n    // Convert buys and sells to a JSON representation\n    let mut buy_sum = 0.0;\n    let mut sell_sum = 0.0;\n\n    for inner_list in &buys {\n        let mut line_value = 1.0;\n        for value in inner_list {\n            line_value = line_value * value;\n        }\n        buy_sum += line_value;\n    }\n\n    println!(\"Buys Sum: {}\", buy_sum);\n\n    for inner_list in &sells {\n        let mut line_value = 1.0;\n        for value in inner_list {\n            line_value = line_value * value;\n        }\n        sell_sum += line_value;\n    }\n\n    println!(\"Sells Sum: {}\", sell_sum);\n\n    return sell_sum;\n}",
            "language": "rust"
        },
        {
            "definition": "/*\n[dependencies]\nserde = { version = \"1.0\", features = [\"derive\"] }\nserde_json = \"1.0\"\n*/\n\nuse arroyo_udf_plugin::udf;\nuse serde_json::Value;\n\n// interface WsLevel {\n//   px: string; // price\n//   sz: string; // size\n//   n: number; // number of orders\n// }\n\nuse std::any::type_name;\n\nfn print_type_of<T>(_: &T) {\n    println!(\"Type: {}\", type_name::<T>());\n}\n\n#[udf]\nfn buy_sum(x: &str) -> f64 {\n    println!(\"Input data: {}\", x);\n    \n    // Attempt to parse the input string into a JSON value\n    let trade: Value = match serde_json::from_str(x) {\n        Ok(val) => val,\n        Err(_) => {\n            return -1.0;\n        }\n    };\n\n    // Extract the timestamp\n    let timestamp = trade.pointer(\"/data/time\")\n        .and_then(|v| v.as_i64())\n        .unwrap_or(0);\n\n    // Extract \"levels\" from \"data\" safely\n    let levels = trade.pointer(\"/data/levels\");\n\n    let (buys, sells) = if let Some(levels) = levels {\n        if let Some(levels_array) = levels.as_array() {\n            // Extract buys (index 0) and convert to integer values in arrays, appending timestamp\n            let buys = levels_array.get(0)\n                .and_then(|v| v.as_array())\n                .map(|array| array.iter().map(|item| {\n                    match item {\n                        Value::Object(map) => {\n                            let n = map.get(\"n\")\n                                .and_then(|v| v.as_i64()) // Parse `n` as i64\n                                .map(|v| v as f64)\n                                .unwrap_or(0.0);\n                            let px = map.get(\"px\")\n                                .and_then(|v| v.as_str())\n                                .and_then(|s| s.parse::<f64>().ok())\n                                .unwrap_or(0.0);\n                            let sz = map.get(\"sz\")\n                                .and_then(|v| v.as_str())\n                                .and_then(|s| s.parse::<f64>().ok())\n                                .unwrap_or(0.0);\n                            vec![n, px, sz]\n                        }\n                        _ => vec![0.0, 0.0, 0.0]\n                    }\n                }).collect::<Vec<Vec<f64>>>())\n                .unwrap_or_else(|| vec![]);\n\n            // Extract sells (index 1) and convert to integer values in arrays, appending timestamp\n            let sells = levels_array.get(1)\n                .and_then(|v| v.as_array())\n                .map(|array| array.iter().map(|item| {\n                    match item {\n                        Value::Object(map) => {\n                            let n = map.get(\"n\")\n                                .and_then(|v| v.as_i64()) // Parse `n` as i64\n                                .map(|v| v as f64)\n                                .unwrap_or(0.0);\n                            let px = map.get(\"px\")\n                                .and_then(|v| v.as_str())\n                                .and_then(|s| s.parse::<f64>().ok())\n                                .unwrap_or(0.0);\n                            let sz = map.get(\"sz\")\n                                .and_then(|v| v.as_str())\n                                .and_then(|s| s.parse::<f64>().ok())\n                                .unwrap_or(0.0);\n                            vec![n, px, sz]\n                        }\n                        _ => vec![0.0, 0.0, 0.0]\n                    }\n                }).collect::<Vec<Vec<f64>>>())\n                .unwrap_or_else(|| vec![]);\n\n            (buys, sells)\n        } else {\n            (vec![], vec![])\n        }\n    } else {\n        (vec![], vec![])\n    };\n\n    // Convert buys and sells to a JSON representation\n    let mut buy_sum = 0.0;\n    let mut sell_sum = 0.0;\n\n    for inner_list in &buys {\n        let mut line_value = 1.0;\n        for value in inner_list {\n            line_value = line_value * value;\n        }\n        buy_sum += line_value;\n    }\n    return buy_sum;\n}",
            "language": "rust"
        }
    ]
}